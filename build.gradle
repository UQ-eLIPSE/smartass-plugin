//+
//
//
//-

//------------------------------------------------------------------------------

import java.util.regex.Matcher
import java.util.regex.Pattern

apply plugin: 'java'


sourceCompatibility = 1.8
targetCompatibility = 1.8


task wrapper(type: Wrapper) { gradleVersion = '2.9' }

repositories { mavenCentral() }

dependencies {

	//
	// 	. compile .
	//
        
        // @TODO: make dependency on 'QuestionModule' Interface Library.

	//
	// 	. testCompile . 
	//
	testCompile 'junit:junit:4.12'

	testCompile 'org.json:json:20141113'
	testCompile 'com.hp.hpl.jena:arq:2.8.3'

	//
	// 	. Updates .
	//
	compile 'ch.qos.logback:logback-core:1.1.3'
	compile 'ch.qos.logback:logback-classic:1.1.3'
	compile 'org.codehaus.groovy:groovy:2.4.4'

        //
        //      . local libs .
        //
	compile fileTree('libs')
}

test { 
        testLogging {
                events 'passed'
        }
}

jar {
	baseName = 'smartass-plugin'
	version = '0.1.0'
}


allprojects {
	gradle.projectsEvaluated {
		tasks.withType(JavaCompile) {
			options.compilerArgs << '-Xlint'
		}
	}
}

task createServiceConf {

        //
        // Generate set of QuesionModule service providers.
        //
        ext.questionModuleSet = { 


                // Set of all QuesitonModules
                Set<File> questionModules = new TreeSet<>()

                // Map class-names to super-class-names - used to build class hierarchy.
                Map<String, String> superClzOf = new HashMap<>()
                superClzOf['SimpleQuestionModule'] = 'QuestionModule'

                // Map super-class-names to a set of all sub-class-files
                Map<String, Set<File> > subClzzOf = new HashMap<>()

                sourceSets.main.java.matching{ it.include('**/question/**') }.each{ File f ->

                        String basename = f.name.replace('.java', '');

                        // Match against file contents where class inherits a base-class:
                        //      Group(1) : package name
                        //      Group(2) : abstract or final stauts (null indicates NOT)
                        //      Group(3) : captures inheritance; either 'implements QuestionModule' or 'extends <some-class>'
                        //      Group(4) : extended (super) class-name
                        //
                        Pattern pattern = Pattern.compile(
                                ".*\\bpackage\\s+([^; ]*);" +
                                ".*\\bpublic\\s+(abstract|final)?\\s*class\\s+${basename}" + 
                                "\\s+(implements\\s+QuestionModule|extends\\s+(\\S+))\\b\\s*\\{.*",
                                Pattern.DOTALL)
                        Matcher matcher = pattern.matcher(f.text)

                        if (matcher.matches()) {
                                String pkgQualifiedName = "${matcher.group(1)}.${basename}"
                                // If class is 'abstract', map class to captured superclass
                                if (matcher.group(2) != null && matcher.group(2).matches('abstract')) {
                                        superClzOf[basename] = ((matcher.group(4) != null) ? matcher.group(4) : "QuestionModule")
                                }
                                // If class directly inherits QuestionModule or SimpleQuestionModule add it to list of QuestionModules.
                                else if (
                                                matcher.group(3).matches('implements\\s+QuestionModule') || 
                                                matcher.group(4) == 'SimpleQuestionModule'
                                ) {
                                        questionModules.add(pkgQualifiedName)
                                        //
                                        //      . in case class is non-abstract super-classes .
                                        //
                                        superClzOf[basename] = 'QuestionModule'
                                } 
                                // Add class to set of classes with super-class. Requires further processing
                                else {
                                        String superClz = matcher.group(4);
                                        if (!subClzzOf.containsKey(superClz)) subClzzOf[superClz] = new HashSet<File>()
                                        subClzzOf[superClz].add(pkgQualifiedName)
                                        //
                                        //      . need to account for non-abstract super-classes .
                                        //
                                        superClzOf[basename] = superClz
                                }
                        // No Match!
                        } else { 
                                // IGNORE: 
                                // @TODO: report files in wrong package?
                        }
                }

                // Generate Set of QuestionModule sub-classes by following super-class-OF-class mapping.
                Set<String> qmSubs = new HashSet<>()
                superClzOf.each{ 
                        String sClz = it.value
                        while (true) {
                                if (sClz == 'QuestionModule') { 
                                        qmSubs.add(it.key) 
                                        break
                                }
                                if (!superClzOf.containsKey(sClz)) break
                                sClz = superClzOf[sClz]
                        }
                }

                // Add additional classes where classes identified as inheriting QuestionModule.
                subClzzOf = subClzzOf.each{
                        if (qmSubs.contains(it.key)) {
                                it.value.each{ questionModules.add(it); }
                                it.value = null
                        }
                }.findAll{ it.value != null }

                return questionModules
        }

        doLast {
                //def srvConfPath = "${buildDir}/resources/META-INF/services/"
                def srvConfPath = "${projectDir}/src/main/resources/META-INF/services/"
                new File( srvConfPath ).mkdirs()
                def srvConfName = 'au.edu.uq.smartass.engine.QuestionModule'
                def qms = questionModuleSet()
                def fos = new FileOutputStream( "${srvConfPath}${srvConfName}")
                qms.each {
                        fos << it
                        fos << "\n"
                }
                fos.close()

                //qms.each{ println it }
                println "[${qms.size()}]"
        }

}

defaultTasks 'clean', 'createServiceConf', 'check', /*'javadoc',*/ 'build'


