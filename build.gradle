//+
//
//
//-

//------------------------------------------------------------------------------


plugins {
        id 'org.ajoberstar.grgit' version '1.5.1'
}

apply plugin: 'java'

sourceCompatibility = 1.8
targetCompatibility = 1.8

task wrapper(type: Wrapper) { gradleVersion = '3.1' }


import org.ajoberstar.grgit.*
import org.ajoberstar.grgit.auth.*
task qmapi {
        def destination = file('qmapi')
        //def repository = 'source.eait.uq.edu.au:smartass'
        def repository = 'repo:smartass'

        if (destination.exists()) {
                println ". . . ."
                println ". . . .  Update Sparse Checkout for :  . . . ."
                println " --> $destination"
                println ". . . ."
                def grgit = Grgit.open(dir: "$destination")
                grgit.pull()
        } else {
                println ". . . ."
                println ". . . .  Create Sparse Checkout for :  . . . ."
                println " --> $destination"
                println ". . . ."
                println ". . . .  initialize git:"
                def grgit = Grgit.init(dir: "$destination")
                def jgit = grgit.repository.jgit
                println ". . . .  config sparse-checkout:"
                def config = jgit.repository.config
                config.setBoolean('core', null, 'sparseCheckout', true)
                println ". . . .  info sparse-checkout:"
                def info_sc = new File("$destination/.git/info/sparse-checkout")
                info_sc.parentFile.mkdirs()
                info_sc.text = 'src/main/java/au/edu/uq/smartass/engine/QuestionModule.java'
                println ". . . .  remote add:"
                def remote = grgit.remote.add(name: 'origin', url: "$repository")
                println ". . . .  git pull origin master:"
                //
                //      . PROBLEM: checks out whole repo (NOT sparse) .
                //
                //grgit.fetch()
                //grgit.pull(remote: 'origin', branch: 'master')
                //
                //      . PROBLEM: Auth Fail - need to specifically set up ssh-agent auth??
                //
                //def pullcmd = jgit.pull()
                //pullcmd.call()

                def proc = 'git pull origin master'.execute(null, new File("$destination"))
                proc.waitFor()
                println ". . . ."
        }
}

project(':qmapi') {
        apply plugin: 'java'
        group = 'au.edu.uq.smartass'
        version = '0.0.1'
        println "* * * * *  $project.name  * * * * *"
}

repositories { mavenCentral() }

dependencies {
	//
	// 	. compile .
	//
        compile project(':qmapi')

	//
	// 	. testCompile . 
	//
	testCompile 'junit:junit:4.12'
}

test { 
        testLogging {
                events 'passed'
        }
}

jar {
	baseName = 'smartass-plugin'
	version = '0.1.0'
}

allprojects {
	gradle.projectsEvaluated {
		tasks.withType(JavaCompile) {
			options.compilerArgs << '-Xlint'
		}
	}
}

//
//      . Create au.edu.uq.smartass.engine.QuestionModule Services file .
//
import java.util.regex.Matcher
import java.util.regex.Pattern
task createServiceConf {

        //
        // Generate set of QuesionModule service providers.
        //
        ext.questionModuleSet = { 
                // Set of all QuesitonModules
                Set<File> questionModules = new TreeSet<>()

                // Map class-names to super-class-names - used to build class hierarchy.
                Map<String, String> superClzOf = new HashMap<>()
                superClzOf['SimpleQuestionModule'] = 'QuestionModule'

                // Map super-class-names to a set of all sub-class-files
                Map<String, Set<File> > subClzzOf = new HashMap<>()

                sourceSets.main.java.matching{ it.include('**/question/**') }.each{ File f ->
                        String basename = f.name.replace('.java', '');

                        // Match against file contents where class inherits a base-class:
                        //      Group(1) : package name
                        //      Group(2) : abstract or final stauts (null indicates NOT)
                        //      Group(3) : captures inheritance; either 'implements QuestionModule' or 'extends <some-class>'
                        //      Group(4) : extended (super) class-name
                        //
                        Pattern pattern = Pattern.compile(
                                ".*\\bpackage\\s+([^; ]*);" +
                                ".*\\bpublic\\s+(abstract|final)?\\s*class\\s+${basename}" + 
                                "\\s+(implements\\s+QuestionModule|extends\\s+(\\S+))\\b\\s*\\{.*",
                                Pattern.DOTALL)
                        Matcher matcher = pattern.matcher(f.text)

                        if (matcher.matches()) {
                                String pkgQualifiedName = "${matcher.group(1)}.${basename}"
                                // If class is 'abstract', map class to captured superclass
                                if (matcher.group(2) != null && matcher.group(2).matches('abstract')) {
                                        superClzOf[basename] = ((matcher.group(4) != null) ? matcher.group(4) : "QuestionModule")
                                }
                                // If class directly inherits QuestionModule or SimpleQuestionModule add it to list of QuestionModules.
                                else if (
                                                matcher.group(3).matches('implements\\s+QuestionModule') || 
                                                matcher.group(4) == 'SimpleQuestionModule'
                                ) {
                                        questionModules.add(pkgQualifiedName)
                                        //
                                        //      . in case class is non-abstract super-classes .
                                        //
                                        superClzOf[basename] = 'QuestionModule'
                                } 
                                // Add class to set of classes with super-class. Requires further processing
                                else {
                                        String superClz = matcher.group(4);
                                        if (!subClzzOf.containsKey(superClz)) subClzzOf[superClz] = new HashSet<File>()
                                        subClzzOf[superClz].add(pkgQualifiedName)
                                        //
                                        //      . need to account for non-abstract super-classes .
                                        //
                                        superClzOf[basename] = superClz
                                }
                        // No Match!
                        } else { 
                                // IGNORE: 
                                // @TODO: report files in wrong package?
                        }
                }

                // Generate Set of QuestionModule sub-classes by following super-class-OF-class mapping.
                Set<String> qmSubs = new HashSet<>()
                superClzOf.each{ 
                        String sClz = it.value
                        while (true) {
                                if (sClz == 'QuestionModule') { 
                                        qmSubs.add(it.key) 
                                        break
                                }
                                if (!superClzOf.containsKey(sClz)) break
                                sClz = superClzOf[sClz]
                        }
                }

                // Add additional classes where classes identified as inheriting QuestionModule.
                subClzzOf = subClzzOf.each{
                        if (qmSubs.contains(it.key)) {
                                it.value.each{ questionModules.add(it); }
                                it.value = null
                        }
                }.findAll{ it.value != null }

                return questionModules
        }

        doLast {
                //def srvConfPath = "${buildDir}/resources/META-INF/services/"
                def srvConfPath = "${projectDir}/src/main/resources/META-INF/services/"
                new File( srvConfPath ).mkdirs()
                def srvConfName = 'au.edu.uq.smartass.engine.QuestionModule'
                def qms = questionModuleSet()
                def fos = new FileOutputStream( "${srvConfPath}${srvConfName}")
                qms.each {
                        fos << it
                        fos << "\n"
                }
                fos.close()

                //qms.each{ println it }
                println "[${qms.size()}]"
        }
}

defaultTasks 'clean', 'createServiceConf', 'check', /*'javadoc',*/ 'build'


